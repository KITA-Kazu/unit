<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å˜ä½æ›ç®—ãƒãƒ£ãƒ¬ãƒ³ã‚¸ (60ç§’)</title>
    <style>
        body { font-family: 'Arial', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; background-color: #f0f8ff; color: #333; padding: 20px; box-sizing: border-box; }
        .container { background-color: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.1); width: 90%; max-width: 600px; text-align: center; }
        h1, h2, h3 { color: #007bff; }
        .screen { display: none; }
        .screen.active { display: block; }
        #category-selection-screen label, #difficulty-selection-screen label { display: block; margin: 10px 0; font-size: 1.1em; }
        #category-selection-screen input[type="checkbox"] { margin-right: 8px; transform: scale(1.2); }
        .difficulty-button { margin: 10px; padding: 15px 30px; font-size: 1.2em; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 20px; text-align: center; text-decoration: none; display: inline-block; font-size: 1em; margin: 8px 4px; cursor: pointer; border-radius: 5px; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #question-area { margin-top: 15px; }
        #question-text { font-size: 1.5em; margin-bottom: 15px; color: #333; }
        .options button { display: block; width: 100%; margin: 8px 0; background-color: #6c757d; font-size: 1.1em; padding: 10px;}
        .options button:hover { background-color: #5a6268; }
        .options button.wrong-highlight { background-color: #dc3545 !important; color: white; }
        .options button.correct-highlight { background-color: #ffc107 !important; color: #333; border: 2px solid #e0a800; }
        #hint-button { background-color: #17a2b8; margin-top: 10px; }
        #hint-button:hover { background-color: #138496; }
        #hint-area { margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; font-style: italic; display: none; color: #495057; }
        #game-timer-display { font-size: 1.5em; color: #dc3545; font-weight: bold; margin-bottom: 10px; }
        #status-bar { display: flex; justify-content: space-around; margin-bottom: 10px; font-size: 1.1em;}
        #results-screen ul { list-style-type: none; padding: 0; }
        #results-screen li { background-color: #f9f9f9; border: 1px solid #eee; padding: 10px; margin-bottom: 10px; border-radius: 5px; text-align: left; }
        #results-screen li strong { color: #dc3545; }
        #results-screen li .correct-answer { color: #ffc107; font-weight: bold; }
        #results-screen li .explanation { font-style: italic; color: #555; margin-top: 5px; }
        #title-display { font-size: 1.8em; color: #ffc107; margin-bottom: 20px; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>å˜ä½æ›ç®—ãƒãƒ£ãƒ¬ãƒ³ã‚¸ (60ç§’)</h1>

        <!-- 1. ã‚«ãƒ†ã‚´ãƒªé¸æŠç”»é¢ -->
        <div id="category-selection-screen" class="screen active">
            <h2>ã‚¹ãƒ†ãƒƒãƒ—1: ç·´ç¿’ã™ã‚‹å˜ä½ã‚’é¸ã‚“ã§ã­ (1ã¤ä»¥ä¸Š)</h2>
            <label><input type="checkbox" name="category" value="length"> é•·ã• (km, m, cm, mm)</label>
            <label><input type="checkbox" name="category" value="weight"> é‡ã• (t, kg, g, mg)</label>
            <label><input type="checkbox" name="category" value="time"> æ™‚é–“ (æ—¥, æ™‚é–“, åˆ†, ç§’)</label>
            <label><input type="checkbox" name="category" value="area"> é¢ç© (kmÂ², ha, a, mÂ², cmÂ²)</label>
            <label><input type="checkbox" name="category" value="volume"> ã‹ã•/å®¹ç© (kL, L, dL, mL)</label>
            <button id="next-to-difficulty-button" disabled>æ¬¡ã¸ (ã‚€ãšã‹ã—ã•é¸æŠ)</button>
        </div>

        <!-- 2. é›£æ˜“åº¦é¸æŠç”»é¢ -->
        <div id="difficulty-selection-screen" class="screen">
            <h2>ã‚¹ãƒ†ãƒƒãƒ—2: ã‚€ãšã‹ã—ã•ã‚’é¸ã‚“ã§ã­</h2>
            <button class="difficulty-button" data-difficulty="easy">ã‹ã‚“ãŸã‚“</button>
            <button class="difficulty-button" data-difficulty="normal">ãµã¤ã†</button>
            <button class="difficulty-button" data-difficulty="hard">é¬¼ãƒ¢ãƒ¼ãƒ‰</button>
            <hr>
            <button id="back-to-category-button">æˆ»ã‚‹ (å˜ä½é¸æŠ)</button>
        </div>

        <!-- 3. ã‚²ãƒ¼ãƒ ç”»é¢ -->
        <div id="game-screen" class="screen">
            <div id="game-timer-display">æ®‹ã‚Šæ™‚é–“: 60ç§’</div>
            <div id="status-bar">
                <span id="question-counter">å•é¡Œ: 1</span> |
                <span id="score-display">å¾—ç‚¹: 0</span>
            </div>
            <div id="question-area">
                <p id="question-text"></p>
                <div class="options" id="options-container"></div>
                <button id="hint-button">ãƒ’ãƒ³ãƒˆã‚’è¦‹ã‚‹</button>
                <div id="hint-area">ã“ã“ã«ãƒ’ãƒ³ãƒˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
            </div>
        </div>

        <!-- 4. çµæœç”»é¢ -->
        <div id="results-screen" class="screen">
             <h2>ãƒãƒ£ãƒ¬ãƒ³ã‚¸çµ‚äº†ï¼</h2>
            <p id="title-display"></p>
            <p id="final-score"></p>
            <p id="questions-answered-count"></p>
            <h3>é–“é•ãˆãŸå•é¡Œã¨è§£èª¬:</h3>
            <ul id="incorrect-answers-list"></ul>
            <p id="no-mistakes-message" style="display:none;">å…¨å•æ­£è§£ï¼ç´ æ™´ã‚‰ã—ã„ï¼</p>
            <button id="retry-incorrect-button" style="display:none;">é–“é•ãˆãŸå•é¡Œã‚’è§£ããªãŠã™ (æ™‚é–“åˆ¶é™ãªã—)</button>
            <button id="play-again-button">ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã™ã‚‹</button>
        </div>
    </div>

    <script>
        const GAME_DURATION_SECONDS = 60;
        const POINTS_PER_CORRECT_ANSWER = 10;
        const PENALTY_FOR_WRONG_ANSWER = -5;

        const MAX_VALUE_EASY_NORMAL = 999999;
        const MAX_VALUE_HARD = 999999;
        const MIN_VALUE_HARD = 0.00001;
        const MAX_ZERO_COUNT_IN_OPTIONS = 5;

        const UNIT_DEFINITIONS = {
            length: { name: "é•·ã•", units: [ { name: "mm", baseFactor: 1 }, { name: "cm", baseFactor: 10 }, { name: "m", baseFactor: 1000 }, { name: "km", baseFactor: 1000000 } ], conversions: [ { from: "m", to: "km", relation: "1000m = 1km" }, { from: "km", to: "m", relation: "1km = 1000m" }, { from: "cm", to: "m", relation: "100cm = 1m" }, { from: "m", to: "cm", relation: "1m = 100cm" }, { from: "mm", to: "cm", relation: "10mm = 1cm" }, { from: "cm", to: "mm", relation: "1cm = 10mm" } ] },
            weight: { name: "é‡ã•", units: [ { name: "mg", baseFactor: 1 }, { name: "g", baseFactor: 1000 }, { name: "kg", baseFactor: 1000000 }, { name: "t", baseFactor: 1000000000 } ], conversions: [ { from: "g", to: "kg", relation: "1000g = 1kg" }, { from: "kg", to: "g", relation: "1kg = 1000g" }, { from: "mg", to: "g", relation: "1000mg = 1g" }, { from: "g", to: "mg", relation: "1g = 1000mg" }, { from: "kg", to: "t", relation: "1000kg = 1t" }, { from: "t", to: "kg", relation: "1t = 1000kg" } ] },
            time: { name: "æ™‚é–“", units: [ { name: "ç§’", baseFactor: 1 }, { name: "åˆ†", baseFactor: 60 }, { name: "æ™‚é–“", baseFactor: 3600 }, { name: "æ—¥", baseFactor: 86400 } ], conversions: [ { from: "ç§’", to: "åˆ†", relation: "60ç§’ = 1åˆ†" }, { from: "åˆ†", to: "ç§’", relation: "1åˆ† = 60ç§’" }, { from: "åˆ†", to: "æ™‚é–“", relation: "60åˆ† = 1æ™‚é–“" }, { from: "æ™‚é–“", to: "åˆ†", relation: "1æ™‚é–“ = 60åˆ†" }, { from: "æ™‚é–“", to: "æ—¥", relation: "24æ™‚é–“ = 1æ—¥" }, { from: "æ—¥", to: "æ™‚é–“", relation: "1æ—¥ = 24æ™‚é–“" } ] },
            area: { name: "é¢ç©", units: [ { name: "cmÂ²", baseFactor: 1 }, { name: "mÂ²", baseFactor: 10000 }, { name: "a", baseFactor: 1000000 }, { name: "ha", baseFactor: 100000000 }, { name: "kmÂ²", baseFactor: 10000000000 } ], conversions: [ { from: "cmÂ²", to: "mÂ²", relation: "10000cmÂ² = 1mÂ²" }, { from: "mÂ²", to: "a", relation: "100mÂ² = 1a" }, { from: "a", to: "ha", relation: "100a = 1ha" }, { from: "ha", to: "kmÂ²", relation: "100ha = 1kmÂ²" }, { from: "mÂ²", to: "ha", relation: "10000mÂ² = 1ha"} ] },
            volume: { name: "ã‹ã•/å®¹ç©", units: [ { name: "mL", baseFactor: 1 }, { name: "dL", baseFactor: 100 }, { name: "L", baseFactor: 1000 }, { name: "kL", baseFactor: 1000000 } ], conversions: [ { from: "mL", to: "dL", relation: "100mL = 1dL" }, { from: "dL", to: "L", relation: "10dL = 1L" }, { from: "L", to: "kL", relation: "1000L = 1kL" }, { from: "mL", to: "L", relation: "1000mL = 1L" } ] }
        };

        const categorySelectionScreen = document.getElementById('category-selection-screen');
        const difficultySelectionScreen = document.getElementById('difficulty-selection-screen');
        const gameScreen = document.getElementById('game-screen');
        const resultsScreen = document.getElementById('results-screen');
        
        const categoryCheckboxes = document.querySelectorAll('input[name="category"]');
        const nextToDifficultyButton = document.getElementById('next-to-difficulty-button');
        const backToCategoryButton = document.getElementById('back-to-category-button');
        const difficultyButtons = document.querySelectorAll('.difficulty-button');

        const gameTimerDisplay = document.getElementById('game-timer-display');
        const questionCounterDisplay = document.getElementById('question-counter');
        const scoreDisplay = document.getElementById('score-display');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const hintButton = document.getElementById('hint-button');
        const hintArea = document.getElementById('hint-area');
        
        const titleDisplay = document.getElementById('title-display');
        const finalScoreDisplay = document.getElementById('final-score');
        const questionsAnsweredCountDisplay = document.getElementById('questions-answered-count');
        const incorrectAnswersList = document.getElementById('incorrect-answers-list');
        const noMistakesMessage = document.getElementById('no-mistakes-message');
        const retryIncorrectButton = document.getElementById('retry-incorrect-button');
        const playAgainButton = document.getElementById('play-again-button');

        let selectedCategories = [];
        let currentDifficulty = '';
        let allGeneratedQuestions = [];
        let currentQuestionIndex = 0;
        let questionsAnsweredInGame = 0;
        let score = 0;
        let incorrectAnswers = [];
        let gameTimerInterval;
        let isRetrying = false;

        categoryCheckboxes.forEach(cb => cb.addEventListener('change', () => {
            nextToDifficultyButton.disabled = getSelectedCategoriesInternal().length === 0;
        }));

        nextToDifficultyButton.addEventListener('click', () => {
            selectedCategories = getSelectedCategoriesInternal();
            if (selectedCategories.length > 0) {
                switchScreen('difficulty-selection-screen');
            }
        });

        backToCategoryButton.addEventListener('click', () => {
            switchScreen('category-selection-screen');
        });

        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                currentDifficulty = button.dataset.difficulty;
                startGameFlow(); // startGameFlowã«å¤‰æ›´
            });
        });
        
        playAgainButton.addEventListener('click', () => {
            isRetrying = false;
            switchScreen('category-selection-screen');
            resetGame();
        });

        retryIncorrectButton.addEventListener('click', () => {
            if (incorrectAnswers.length > 0) {
                isRetrying = true;
                allGeneratedQuestions = [...incorrectAnswers];
                incorrectAnswers.forEach(q => delete q.userAnswer);
                currentQuestionIndex = 0;
                questionsAnsweredInGame = 0;
                hintArea.style.display = 'none';
                hintButton.disabled = false;
                switchScreen('game-screen');
                gameTimerDisplay.textContent = "è§£ããªãŠã—ä¸­ (æ™‚é–“åˆ¶é™ãªã—)";
                loadNextQuestion();
            }
        });
        
        hintButton.addEventListener('click', showHint);

        function switchScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function getSelectedCategoriesInternal() { // é–¢æ•°åã‚’å¤‰æ›´ã—ã¦è¡çªã‚’é¿ã‘ã‚‹
            return Array.from(categoryCheckboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
        }
        
        function resetGame() {
            selectedCategories = [];
            currentDifficulty = '';
            allGeneratedQuestions = [];
            currentQuestionIndex = 0;
            questionsAnsweredInGame = 0;
            score = 0;
            incorrectAnswers = [];
            clearInterval(gameTimerInterval);
            gameTimerDisplay.textContent = `æ®‹ã‚Šæ™‚é–“: ${GAME_DURATION_SECONDS}ç§’`;
            scoreDisplay.textContent = "å¾—ç‚¹: 0";
            questionCounterDisplay.textContent = "å•é¡Œ: 1";
            hintArea.style.display = 'none';
            hintButton.disabled = false;
            categoryCheckboxes.forEach(cb => cb.checked = false);
            nextToDifficultyButton.disabled = true;
        }

        function startGameFlow() { // startGameã‹ã‚‰å¤‰æ›´ã—ã¦ã€å•é¡Œç”Ÿæˆã¨é–‹å§‹ã‚’åˆ†é›¢
            allGeneratedQuestions = generateAllPossibleQuestions(selectedCategories, currentDifficulty);
            if (allGeneratedQuestions.length === 0) {
                alert("å•é¡Œã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚«ãƒ†ã‚´ãƒªã‚„é›£æ˜“åº¦ã‚’å¤‰ãˆã¦ãŠè©¦ã—ãã ã•ã„ã€‚");
                switchScreen('difficulty-selection-screen');
                return;
            }
            for (let i = allGeneratedQuestions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allGeneratedQuestions[i], allGeneratedQuestions[j]] = [allGeneratedQuestions[j], allGeneratedQuestions[i]];
            }
            
            currentQuestionIndex = 0;
            questionsAnsweredInGame = 0;
            score = 0;
            incorrectAnswers = [];
            scoreDisplay.textContent = "å¾—ç‚¹: 0";
            questionCounterDisplay.textContent = "å•é¡Œ: 1";
            hintArea.style.display = 'none';
            hintButton.disabled = false;

            switchScreen('game-screen');
            loadNextQuestion();
            if (!isRetrying) {
                 startOverallGameTimer();
            }
        }
        
        function startOverallGameTimer() {
            let timeLeft = GAME_DURATION_SECONDS;
            gameTimerDisplay.textContent = `æ®‹ã‚Šæ™‚é–“: ${timeLeft}ç§’`;
            gameTimerInterval = setInterval(() => {
                timeLeft--;
                gameTimerDisplay.textContent = `æ®‹ã‚Šæ™‚é–“: ${timeLeft}ç§’`;
                if (timeLeft <= 0) {
                    clearInterval(gameTimerInterval);
                    endGame();
                }
            }, 1000);
        }

        function loadNextQuestion() {
            hintArea.style.display = 'none';
            hintButton.disabled = false;
            optionsContainer.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('correct-highlight', 'wrong-highlight');
                btn.style.backgroundColor = ''; 
                btn.disabled = false;
            });

            if (currentQuestionIndex < allGeneratedQuestions.length) {
                const question = allGeneratedQuestions[currentQuestionIndex];
                if (!question) { // ä¸‡ãŒä¸€questionãŒundefinedã®å ´åˆ
                    console.error("Error: Current question is undefined. Index:", currentQuestionIndex, "Pool size:", allGeneratedQuestions.length);
                    if (!isRetrying) endGame(); else showResultsScreen();
                    return;
                }
                questionText.textContent = question.text;
                questionCounterDisplay.textContent = `å•é¡Œ: ${questionsAnsweredInGame + 1}`;
                optionsContainer.innerHTML = '';
                question.options.forEach((optionText, index) => {
                    const button = document.createElement('button');
                    button.textContent = optionText;
                    button.addEventListener('click', () => selectAnswer(index, button));
                    optionsContainer.appendChild(button);
                });
            } else {
                if (!isRetrying) endGame();
                else {
                    alert("é–“é•ãˆãŸå•é¡Œã‚’ã™ã¹ã¦è§£ããªãŠã—ã¾ã—ãŸï¼");
                    showResultsScreen();
                }
            }
        }
        
        function showHint() {
            const question = allGeneratedQuestions[currentQuestionIndex];
            if (question && question.hint) {
                hintArea.textContent = question.hint;
                hintArea.style.display = 'block';
                hintButton.disabled = true;
            }
        }

        function selectAnswer(selectedIndex, buttonElement) {
            const question = allGeneratedQuestions[currentQuestionIndex];
            if (!question) { console.error("selectAnswer: question undefined"); return; } // å®‰å…¨ç­–
            const isCorrect = selectedIndex === question.correctAnswerIndex;
            hintButton.disabled = true;

            optionsContainer.querySelectorAll('button').forEach((btn, idx) => {
                btn.disabled = true;
                if (idx === question.correctAnswerIndex) {
                    btn.classList.add('correct-highlight');
                }
            });

            if (isCorrect) {
                score += POINTS_PER_CORRECT_ANSWER;
            } else {
                score += PENALTY_FOR_WRONG_ANSWER;
                if (buttonElement) buttonElement.classList.add('wrong-highlight');
                const incorrectQ = { ...question, userAnswer: buttonElement ? buttonElement.textContent : "ä¸æ˜" };
                if(!isRetrying) incorrectAnswers.push(incorrectQ);
            }
            score = Math.max(0, score);
            scoreDisplay.textContent = `å¾—ç‚¹: ${score}`;
            questionsAnsweredInGame++;
            currentQuestionIndex++;

            if (isRetrying || (gameTimerInterval && parseInt(gameTimerDisplay.textContent.split(" ")[1] || "0") > 0) ) {
                setTimeout(() => {
                    loadNextQuestion();
                }, 700);
            } else if (!isRetrying) {
                 endGame();
            }
        }
        
        function endGame() {
            clearInterval(gameTimerInterval);
            gameTimerDisplay.textContent = "æ™‚é–“åˆ‡ã‚Œï¼";
            setTimeout(showResultsScreen, 1000);
        }

        function showResultsScreen() {
            switchScreen('results-screen');
            titleDisplay.textContent = getTitle(score);
            finalScoreDisplay.textContent = `æœ€çµ‚å¾—ç‚¹: ${score}ç‚¹`;
            questionsAnsweredCountDisplay.textContent = `è§£ç­”æ•°: ${questionsAnsweredInGame}å•`;

            incorrectAnswersList.innerHTML = '';
            if (incorrectAnswers.length > 0) {
                noMistakesMessage.style.display = 'none';
                retryIncorrectButton.style.display = 'inline-block';
                incorrectAnswers.forEach(q => {
                    const li = document.createElement('li');
                    const displayQuestionValue = q.questionValue !== undefined ? q.questionValue : q.text.split(" ")[0];
                    li.innerHTML = `<p><strong>å•é¡Œ:</strong> ${displayQuestionValue} ã¯ï¼Ÿ (å…ƒã®å•é¡Œæ–‡:${q.text})</p> <p><strong>ã‚ãªãŸã®ç­”ãˆ:</strong> ${q.userAnswer}</p> <p><strong class="correct-answer">æ­£ã—ã„ç­”ãˆ:</strong> ${q.correctValue}</p> <p class="explanation"><strong>è§£èª¬:</strong> ${q.explanation}</p>`;
                    incorrectAnswersList.appendChild(li);
                });
            } else {
                noMistakesMessage.style.display = 'block';
                retryIncorrectButton.style.display = 'none';
                 if(questionsAnsweredInGame > 0) noMistakesMessage.textContent = "å…¨å•æ­£è§£ï¼ç´ æ™´ã‚‰ã—ã„ï¼";
                 else noMistakesMessage.textContent = "æ™‚é–“å†…ã«è§£ç­”ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã‚ˆã†ï¼";
            }
        }

        function getTitle(currentScore) {
            if (currentScore >= 200) return "ğŸ† å˜ä½æ›ç®—ã‚´ãƒƒãƒ‰ ğŸ†";
            if (currentScore >= 150) return "ğŸ‰ å˜ä½æ›ç®—ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³ï¼ ğŸ‰";
            if (currentScore >= 100) return "ğŸ¥‡ å˜ä½æ›ç®—ãƒã‚¹ã‚¿ãƒ¼ ğŸ¥‡";
            if (currentScore >= 70) return "ğŸ¥ˆ å˜ä½æ›ç®—ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ ğŸ¥ˆ";
            if (currentScore >= 40) return "ğŸ¥‰ å˜ä½æ›ç®—ã˜ã‚‡ã†ãš ğŸ¥‰";
            if (currentScore >= 10) return "ğŸ’ª ã‚‚ã†ã™ã“ã—ï¼ãŒã‚“ã°ã‚ã† ğŸ’ª";
            return "ğŸ“ ãƒ•ã‚¡ã‚¤ãƒˆï¼ã¾ãŸæŒ‘æˆ¦ã—ã‚ˆã† ğŸ“";
        }
        
        function gcd(a,b){ if(b===0) return a; return gcd(b, a%b); }

        function formatNumber(num, difficulty) {
            let s;
            if (difficulty !== 'hard' || (typeof num === 'number' && Number.isInteger(num)) ) {
                return String(Math.round(num));
            }
            if (num === 0) return "0";
            s = parseFloat(num.toFixed(MAX_ZERO_COUNT_IN_OPTIONS + 3)).toString();
            if (s.includes('.')) { s = s.replace(/0+$/, '').replace(/\.$/, ''); }
            return s;
        }

        function hasAcceptableZeroCount(value, difficulty) {
            const numStr = formatNumber(value, difficulty);
            if (numStr.includes('e')) return true;
            if (numStr.includes('.') && difficulty === 'hard') return true;
            let significantPart = numStr;
            let zeroCount = 0;
            if (significantPart.length > 1 && significantPart !== "0") {
                 for(let i = significantPart.length -1; i >=0; i--) { if(significantPart[i] === '0') zeroCount++; else break; }
            }
            return zeroCount <= MAX_ZERO_COUNT_IN_OPTIONS;
        }

        function isValueWithinLimits(value, difficulty) {
            const numStr = formatNumber(value, difficulty);
            if (numStr.includes('e')) { return true; }

            if (!hasAcceptableZeroCount(value, difficulty) && difficulty !== 'hard') return false;

            const num = parseFloat(numStr); // parseFloatã§æ•°å€¤ã«æˆ»ã—ã¦æ¯”è¼ƒ
            if (difficulty !== 'hard') {
                return Number.isInteger(num) && num >= (difficulty === 'easy' ? 0 : 1) && num <= MAX_VALUE_EASY_NORMAL;
            } else {
                const absValue = Math.abs(num);
                if (num === 0) return true;
                // MIN_VALUE_HARD ã‚ˆã‚Šå°ã•ã„æ­£ã®æ•°ã‚‚è¨±å®¹ã™ã‚‹ (ä¾‹: 0.00005 ãªã©)
                return absValue > 0 && absValue <= MAX_VALUE_HARD;
            }
        }


        function generateSingleQuestion(categoryKey, difficulty) {
            const MAX_ATTEMPTS_PER_Q = 250;
            for (let attempt = 0; attempt < MAX_ATTEMPTS_PER_Q; attempt++) {
                const categoryData = UNIT_DEFINITIONS[categoryKey];
                if (!categoryData || !categoryData.units) {
                    console.error(`Error: UNIT_DEFINITIONS for ${categoryKey} is invalid.`);
                    return null;
                }
                const availableUnits = categoryData.units;
                if (availableUnits.length < 2) return null;

                let unit1Idx, unit2Idx, fromUnit, toUnit;
                let questionValueNum, correctAnswerValueNum;

                if (difficulty === 'easy') {
                    const easyPairs = [];
                    for(let i=0; i < availableUnits.length -1; i++){
                        easyPairs.push([i, i+1]); easyPairs.push([i+1, i]);
                    }
                    // ç‰¹åˆ¥ãªãƒšã‚¢ã®è¿½åŠ  (ä¾‹: é•·ã•ã®mã¨km)
                    if (categoryKey === 'length') {
                        const mIdx = availableUnits.findIndex(u => u.name === 'm');
                        const kmIdx = availableUnits.findIndex(u => u.name === 'km');
                        if (mIdx !== -1 && kmIdx !== -1) {
                            easyPairs.push([mIdx, kmIdx]); easyPairs.push([kmIdx, mIdx]);
                        }
                    }
                    if (categoryKey === 'volume') {
                        const lIdx = availableUnits.findIndex(u => u.name === 'L');
                        const mlIdx = availableUnits.findIndex(u => u.name === 'mL');
                        const klIdx = availableUnits.findIndex(u => u.name === 'kL');
                        if (lIdx !== -1 && mlIdx !== -1) { easyPairs.push([lIdx, mlIdx]); easyPairs.push([mlIdx, lIdx]); }
                        if (lIdx !== -1 && klIdx !== -1) { easyPairs.push([lIdx, klIdx]); easyPairs.push([klIdx, lIdx]); }
                    }

                    if(easyPairs.length === 0) {
                        unit1Idx = Math.floor(Math.random() * availableUnits.length);
                        do { unit2Idx = Math.floor(Math.random() * availableUnits.length); } while (unit1Idx === unit2Idx);
                    } else {
                        const pair = easyPairs[Math.floor(Math.random() * easyPairs.length)];
                        unit1Idx = pair[0]; unit2Idx = pair[1];
                         if (unit1Idx === undefined || unit2Idx === undefined || unit1Idx >= availableUnits.length || unit2Idx >= availableUnits.length || unit1Idx === unit2Idx) {
                            continue; // ä¸æ­£ãªãƒšã‚¢ãªã‚‰å†è©¦è¡Œ
                        }
                    }
                } else {
                    unit1Idx = Math.floor(Math.random() * availableUnits.length);
                    do { unit2Idx = Math.floor(Math.random() * availableUnits.length); } while (unit1Idx === unit2Idx);
                }
                fromUnit = availableUnits[unit1Idx];
                toUnit = availableUnits[unit2Idx];

                if (difficulty === 'easy') {
                    questionValueNum = 1;
                    if (categoryKey === 'time') {
                        if (fromUnit.name === "æ—¥" && toUnit.name === "æ™‚é–“") questionValueNum = 1;
                        else if (fromUnit.name === "æ™‚é–“" && toUnit.name === "åˆ†") questionValueNum = 1;
                        else if (fromUnit.name === "åˆ†" && toUnit.name === "ç§’") questionValueNum = 1;
                        else if (fromUnit.name === "æ™‚é–“" && toUnit.name === "æ—¥") questionValueNum = 24;
                        else if (fromUnit.name === "åˆ†" && toUnit.name === "æ™‚é–“") questionValueNum = 60;
                        else if (fromUnit.name === "ç§’" && toUnit.name === "åˆ†") questionValueNum = 60;
                        else { if(Math.random() < 0.85) continue; questionValueNum = 1;}
                    }
                } else if (difficulty === 'normal') {
                    if (categoryKey === 'time') {
                        const timeVals = [1,2,3,4,5,6,10,12,15,20,24,30,45,50,60,90,120,150,180,240,300,360,480,600];
                        questionValueNum = timeVals[Math.floor(Math.random() * timeVals.length)];
                        if ((fromUnit.name === "æ—¥" && toUnit.name === "ç§’") || (toUnit.name === "æ—¥" && fromUnit.name === "ç§’")) {if(Math.random()<0.95)continue;};
                         if (fromUnit.baseFactor / toUnit.baseFactor > 72000 || toUnit.baseFactor / fromUnit.baseFactor > 72000) {if(Math.random()<0.95)continue;}; // ã•ã‚‰ã«åˆ¶é™
                    } else {
                        const normalValues = [2,3,4,5,6,7,8,9,10,12,15,20,25,30,40,50,60,75,80,100,120,150,200,250,300,400,500,600,750,800,1000,1250,1500,2000,2500,3000,4000,5000, 10000, 20000];
                        questionValueNum = normalValues[Math.floor(Math.random() * normalValues.length)];
                    }
                } else { // difficulty === 'hard'
                    if (categoryKey === 'time') {
                        const timeValsHard = [1.5, 2.5, 0.5, 0.25, 75, 135, 210, 1500, 48, 72, 90, 100, 3600, 6000, 7200, 8640];
                        questionValueNum = timeValsHard[Math.floor(Math.random() * timeValsHard.length)];
                        if(Math.random() < 0.5) {
                             const timeVals = [1,2,3,4,5,6,10,12,15,20,24,30,45,50,60,90,120,150,180,240,300,360,480,600,1200,1440];
                             questionValueNum = timeVals[Math.floor(Math.random() * timeVals.length)];
                        }
                    } else {
                        const hardBase = [0.01, 0.02, 0.025, 0.04, 0.05, 0.1, 0.125, 0.2, 0.25, 0.4, 0.5, 0.75, 0.8, 1, 1.2, 1.25, 1.5, 1.6, 2, 2.4, 2.5, 3, 3.5, 4, 5, 6, 7.5, 8, 10, 12, 12.5, 15, 16, 20, 24, 25, 30, 40, 50, 60, 75, 80, 100, 120, 125, 150, 160, 200, 240, 250, 300, 400, 500, 600, 750, 800, 1000, 1200, 1500, 1600, 2000, 2500, 3000, 4000, 5000, 6000, 8000, 10000];
                        questionValueNum = hardBase[Math.floor(Math.random() * hardBase.length)];
                        const scaleRatio = fromUnit.baseFactor / toUnit.baseFactor;
                        if (scaleRatio > 100000 && questionValueNum > 0.1) questionValueNum /= ((Math.floor(Math.random()*5)+1)*1000);
                        else if (scaleRatio > 10000 && questionValueNum > 0.5) questionValueNum /= ((Math.floor(Math.random()*5)+1)*100);
                        else if (scaleRatio > 1000 && questionValueNum > 1) questionValueNum /= ((Math.floor(Math.random()*5)+1)*10);
                        if (scaleRatio < 0.00001 && questionValueNum < 10000 && questionValueNum !==0) questionValueNum *= ((Math.floor(Math.random()*5)+1)*1000);
                        else if (scaleRatio < 0.0001 && questionValueNum < 1000 && questionValueNum !==0) questionValueNum *= ((Math.floor(Math.random()*5)+1)*100);
                        else if (scaleRatio < 0.01 && questionValueNum < 100 && questionValueNum !==0) questionValueNum *= ((Math.floor(Math.random()*5)+1)*10);
                    }
                    questionValueNum = parseFloat(questionValueNum.toFixed(4));
                }
                
                correctAnswerValueNum = (questionValueNum * fromUnit.baseFactor) / toUnit.baseFactor;

                if (difficulty !== 'hard') {
                    let originalCorrect = correctAnswerValueNum;
                    correctAnswerValueNum = Math.round(correctAnswerValueNum);
                     // ç­”ãˆãŒ0ã«ãªã‚‹å ´åˆã€å…ƒã®å€¤ãŒéå¸¸ã«å°ã•ã„å ´åˆãªã®ã§ã€questionValueNumã‚’èª¿æ•´ã™ã‚‹
                    if (correctAnswerValueNum === 0 && originalCorrect > 0 && difficulty !== 'easy') { // ã‹ã‚“ãŸã‚“ã¯0ã®ç­”ãˆã‚’è¨±å®¹
                         // questionValueNumã‚’ã€ç­”ãˆãŒæœ€ä½ã§ã‚‚1ã«ãªã‚‹ã‚ˆã†ã«èª¿æ•´
                        let minQ = toUnit.baseFactor / fromUnit.baseFactor; // ç­”ãˆãŒ1ã«ãªã‚‹questionValue
                        if (minQ < 1 && Number.isInteger(1/minQ)) minQ = 1/minQ; // é€†æ•°ã‚‚è€ƒæ…®
                        else minQ = Math.max(1, Math.ceil(minQ));
                        questionValueNum = minQ;
                        correctAnswerValueNum = (questionValueNum * fromUnit.baseFactor) / toUnit.baseFactor;
                        correctAnswerValueNum = Math.round(correctAnswerValueNum);
                    }
                    if (!Number.isInteger(questionValueNum) && categoryKey !== 'time') { // æ™‚é–“ä»¥å¤–ã¯å•é¡Œã‚‚æ•´æ•°ã«ã—ãŸã„
                        questionValueNum = Math.round(questionValueNum);
                        if(questionValueNum === 0 && difficulty !== 'easy') questionValueNum = 1;
                        correctAnswerValueNum = (questionValueNum * fromUnit.baseFactor) / toUnit.baseFactor;
                        correctAnswerValueNum = Math.round(correctAnswerValueNum);
                    }
                    if (!Number.isInteger(correctAnswerValueNum) || correctAnswerValueNum < (difficulty === 'easy' ? 0:1) ) continue;
                    if (questionValueNum < (difficulty === 'easy' ? 0:1)) continue; // å•é¡Œã®å€¤ã‚‚0ä»¥ä¸Šã¾ãŸã¯1ä»¥ä¸Š
                } else {
                     correctAnswerValueNum = parseFloat(correctAnswerValueNum.toFixed(5));
                     if (correctAnswerValueNum === 0 && questionValueNum !== 0) { // é¬¼ãƒ¢ãƒ¼ãƒ‰ã§ç­”ãˆãŒ0ã«ãªã‚‹ã®ã¯é¿ã‘ã‚‹ (å•é¡ŒãŒ0ã§ãªã„é™ã‚Š)
                         if (Math.abs(questionValueNum * fromUnit.baseFactor / toUnit.baseFactor) < MIN_VALUE_HARD) continue;
                     }
                }

                if (!isValueWithinLimits(questionValueNum, difficulty) || !isValueWithinLimits(correctAnswerValueNum, difficulty)) {
                    continue;
                }

                const qText = `${formatNumber(questionValueNum, difficulty)}${fromUnit.name} ã¯ï¼Ÿ`;
                const options = new Set();
                const correctAnswerFormatted = formatNumber(correctAnswerValueNum, difficulty);
                options.add(correctAnswerFormatted);
                let distractorCount = 0;

                if (difficulty === 'easy' && categoryKey !== 'time') {
                     const easyFactors = [10, 0.1, 100, 0.01, 1000, 0.001, 0];
                    easyFactors.sort(() => Math.random() -0.5);
                    for(const factor of easyFactors){
                        if(options.size >= 4) break;
                        let distVal = (factor === 0 && correctAnswerValueNum !== 0) ? 0 : correctAnswerValueNum * factor;
                        if (correctAnswerValueNum === 0) {
                             const zeroAnsOpts = [0, 1, 10, 100, 1000];
                             distVal = zeroAnsOpts[Math.floor(Math.random()*zeroAnsOpts.length)];
                        } else { distVal = Math.round(distVal); }
                        const dist = formatNumber(distVal, difficulty);
                        if(!options.has(dist) && dist !== correctAnswerFormatted && isValueWithinLimits(distVal,difficulty)) options.add(dist);
                    }
                } else if (categoryKey === 'time' && (difficulty === 'easy' || difficulty === 'normal') ) {
                    let baseAns = Math.round(correctAnswerValueNum);
                    const timeOptionDeltas = [Math.max(1, Math.floor(baseAns*0.5)), Math.max(1,Math.floor(baseAns*0.25)), baseAns*2, baseAns*3, Math.max(0, baseAns-1), baseAns+1, baseAns*10, Math.max(0, Math.round(baseAns/10))];
                    if (baseAns === 0 && difficulty==='easy') timeOptionDeltas.push(0,1,60,24);
                    timeOptionDeltas.sort(() => Math.random()-0.5);
                    for(const delta of timeOptionDeltas){
                        if(options.size >=4) break;
                        let distVal;
                        if(Math.random() < 0.6 && baseAns >= delta ) distVal = baseAns - delta; // baseAns >= delta ã§ãªã„ã¨è² ã«ãªã‚‹
                        else distVal = baseAns + delta;
                        distVal = Math.max(0, Math.round(distVal));
                        const distStr = formatNumber(distVal, difficulty);
                        if(!options.has(distStr) && distStr !== correctAnswerFormatted && isValueWithinLimits(distVal, difficulty)) options.add(distStr);
                    }
                }
                
                const distractorPowers = difficulty === 'hard' ? [-4,-3, -2, -1, 1, 2, 3, 4] : [-2, -1, 1, 2, 0.5, 2.5]; // ãµã¤ã†ã«ã‚‚å°æ•°ç‚¹ã‚’å°‘ã—æ··ãœã‚‹
                distractorPowers.sort(() => Math.random() - 0.5);
                for (const power of distractorPowers) {
                    if (options.size >= 4) break;
                    let distractorNum = correctAnswerValueNum * ( (typeof power === 'number' && (power < 0 || power > 0 && power <=4)) ? Math.pow(10, power) : power ); // 0.5ã‚„2.5ã®ã‚ˆã†ãªä¿‚æ•°ã‚‚ä½¿ãˆã‚‹ã‚ˆã†ã«
                    if (difficulty !== 'hard') distractorNum = Math.round(distractorNum);
                    else distractorNum = parseFloat(distractorNum.toFixed(5));

                    if (isValueWithinLimits(distractorNum, difficulty) && (difficulty === 'hard' || hasAcceptableZeroCount(distractorNum, difficulty))) {
                        const formattedDistractor = formatNumber(distractorNum, difficulty);
                        if (!options.has(formattedDistractor) && formattedDistractor !== correctAnswerFormatted) {
                            options.add(formattedDistractor);
                        }
                    }
                }
                while (options.size < 4 && distractorCount < 50) {
                    distractorCount++;
                    let distractorNum;
                    if(difficulty !== 'hard' && Math.random() < 0.7) {
                        distractorNum = Math.round(correctAnswerValueNum) + (Math.floor(Math.random()* (difficulty==='easy'? 5:15) )+1) * (Math.random() > 0.5 ? 1: -1);
                        distractorNum = Math.max((difficulty === 'easy' ? 0 : 1), distractorNum);
                    } else {
                        distractorNum = correctAnswerValueNum * Math.pow(10, (Math.floor(Math.random()* (difficulty==='easy'?2: (difficulty==='normal'?3:4)) )+1) * (Math.random() > 0.5 ? 1: -1));
                    }
                     if (difficulty !== 'hard') distractorNum = Math.round(distractorNum);
                     else distractorNum = parseFloat(distractorNum.toFixed(5));

                    if (isValueWithinLimits(distractorNum, difficulty) && (difficulty === 'hard' || hasAcceptableZeroCount(distractorNum, difficulty))) {
                        const formattedDistractor = formatNumber(distractorNum, difficulty);
                        if (!options.has(formattedDistractor) && formattedDistractor !== correctAnswerFormatted) {
                            options.add(formattedDistractor);
                        }
                    }
                }
                const fillOptionsBase = difficulty === 'easy' ? [0,1,10,100,1000] : [1,10,100,1000,0.1,0.01, 0.001, 0.5, 2, 5];
                let fillOptions = [];
                if (difficulty !== 'hard') {
                    fillOptions = fillOptionsBase.filter(n => Number.isInteger(n) && n>= (difficulty==='easy'?0:1) );
                } else {
                    fillOptions = fillOptionsBase;
                }

                while (options.size < 4) {
                    if (fillOptions.length === 0) {
                        options.add(formatNumber(correctAnswerValueNum + options.size + Math.random()*0.1, difficulty));
                        if(options.size >=4) break; continue;
                    }
                    const fillVal = fillOptions[Math.floor(Math.random()*fillOptions.length)];
                    const fillStr = formatNumber(fillVal, difficulty);
                    if(!options.has(fillStr) && fillStr !== correctAnswerFormatted && isValueWithinLimits(fillVal,difficulty)) options.add(fillStr);
                    else options.add(formatNumber(correctAnswerValueNum / (options.size + Math.random()*0.5 + 1.05), difficulty));
                    if(options.size >= 4) break;
                }

                const shuffledOptions = Array.from(options).sort(() => Math.random() - 0.5);
                const correctIdx = shuffledOptions.findIndex(opt => opt === correctAnswerFormatted);

                let hintText = `ãƒ’ãƒ³ãƒˆ: ${fromUnit.name} ã¨ ${toUnit.name} ã®é–¢ä¿‚ã‚’æ€ã„å‡ºãã†ã€‚`;
                const directConv = categoryData.conversions.find(c => (c.from === fromUnit.name && c.to === toUnit.name) || (c.from === toUnit.name && c.to === fromUnit.name));
                if (directConv) hintText = `ãƒ’ãƒ³ãƒˆ: ${directConv.relation}`;

                let explanation = `1${fromUnit.name} ã¯ ${formatNumber(fromUnit.baseFactor / toUnit.baseFactor, difficulty)}${toUnit.name} ã§ã™ã€‚ ã ã‹ã‚‰ã€${formatNumber(questionValueNum, difficulty)}${fromUnit.name} ã¯ ${correctAnswerFormatted}${toUnit.name} ã«ãªã‚Šã¾ã™ã€‚`;

                return {
                    text: qText, options: shuffledOptions.map(opt => `${opt}${toUnit.name}`),
                    correctAnswerIndex: correctIdx, correctValue: `${correctAnswerFormatted}${toUnit.name}`,
                    questionValue: `${formatNumber(questionValueNum, difficulty)}${fromUnit.name}`, 
                    explanation: explanation, hint: hintText, category: categoryKey
                };
            }
            // console.warn(`generateSingleQuestion: ${categoryKey} (${difficulty}) ã§å•é¡Œç”Ÿæˆã« ${MAX_ATTEMPTS_PER_Q}å›å¤±æ•—ã—ã¾ã—ãŸã€‚`);
            return null;
        }

        function generateAllPossibleQuestions(categories, difficulty) {
            const questions = [];
            // å„ã‚«ãƒ†ã‚´ãƒªã‹ã‚‰å‡ç­‰ã«å•é¡Œã‚’é¸ã¶ãŸã‚ã€ã‚«ãƒ†ã‚´ãƒªã”ã¨ã«ä¸Šé™ã‚’è¨­å®š
            // ãŸã ã—ã€æ™‚é–“å†…ã«å¤šãã®å•é¡Œã«ç­”ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã€ãƒ—ãƒ¼ãƒ«ã¯å¤šã‚ã«ç”¨æ„ã™ã‚‹
            const questionsToAimPerCategory = Math.max(5, Math.ceil( (GAME_DURATION_SECONDS / 3) / categories.length) + 15); // 1å•3ç§’ã¨ä»®å®š + Î±
            let totalGenerated = 0;

            categories.forEach(catKey => {
                let generatedForThisCategory = 0;
                for (let i = 0; i < questionsToAimPerCategory * 5 && generatedForThisCategory < questionsToAimPerCategory; i++) { // è©¦è¡Œå›æ•°ã«ä½™è£•ã‚’æŒãŸã›ã‚‹
                    const q = generateSingleQuestion(catKey, difficulty);
                    if (q) {
                        if (!questions.find(exQ => exQ.text === q.text && exQ.correctValue === q.correctValue)) {
                            questions.push(q);
                            generatedForThisCategory++;
                            totalGenerated++;
                        }
                    }
                }
            });
             // ã‚‚ã—å•é¡ŒãŒæ¥µç«¯ã«å°‘ãªã„å ´åˆï¼ˆä¾‹ãˆã°1ã‚«ãƒ†ã‚´ãƒªã®ã¿ã§ç”ŸæˆãŒé›£ã—ã„å ´åˆï¼‰ã€ã‚«ãƒ†ã‚´ãƒªç„¡è¦–ã§è¿½åŠ ç”Ÿæˆã‚’è©¦ã¿ã‚‹
            let emergencyAttempts = 0;
            while(questions.length < Math.min(20, categories.length * 5) && emergencyAttempts < 100){ // æœ€ä½ã§ã‚‚20å•ã‹ã‚«ãƒ†ã‚´ãƒª*5å•ã¯æ¬²ã—ã„
                 const randomCatKey = categories[Math.floor(Math.random() * categories.length)];
                 const q = generateSingleQuestion(randomCatKey, difficulty);
                 if(q && !questions.find(exQ => exQ.text === q.text && exQ.correctValue === q.correctValue)){
                     questions.push(q);
                 }
                 emergencyAttempts++;
            }

            if(questions.length === 0) console.warn("æœ€çµ‚çš„ã«å•é¡ŒãŒ1å•ã‚‚ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚");
            return questions;
        }
        
        switchScreen('category-selection-screen');
        resetGame();

    </script>
</body>
</html>